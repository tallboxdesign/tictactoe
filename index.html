<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>5x5 Tic-Tac-Toe - YONI vs TATI</title>
  <!-- PeerJS for WebRTC peer-to-peer connections -->
  <script src="https://unpkg.com/peerjs@1.4.7/dist/peerjs.min.js"></script>
  <style>
    body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background-color: #f0f0f0;
      font-family: Arial, sans-serif;
    }
    #info {
      position: absolute;
      top: 10px;
      width: 100%;
      text-align: center;
      color: #333;
      font-size: 18px;
      z-index: 100;
      pointer-events: none;
    }
    #gameStatus {
      position: absolute;
      bottom: 20px;
      width: 100%;
      text-align: center;
      color: #333;
      font-size: 24px;
      font-weight: bold;
      z-index: 100;
      pointer-events: none;
    }
    #resetButton {
      position: absolute;
      top: 60px;
      left: 50%;
      transform: translateX(-50%);
      padding: 10px 20px;
      font-size: 16px;
      background-color: #4CAF50;
      color: white;
      border: none;
      border-radius: 5px;
      cursor: pointer;
      z-index: 100;
      display: none; /* Hidden by default, shown when appropriate */
    }
    #resetButton:hover {
      background-color: #45a049;
    }
    #scoreBoard {
      position: absolute;
      top: 10px;
      right: 20px;
      background-color: rgba(255, 255, 255, 0.8);
      padding: 10px;
      border-radius: 5px;
      z-index: 100;
      font-size: 16px;
    }
    #mathModal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.7);
      z-index: 200;
      justify-content: center;
      align-items: center;
    }
    .modal-content {
      background-color: white;
      padding: 30px;
      border-radius: 10px;
      text-align: center;
      max-width: 500px;
      width: 90%;
    }
    #answerInput {
      margin: 20px 0;
      padding: 10px;
      font-size: 18px;
      width: 100px;
    }
    .btn {
      padding: 10px 20px;
      margin: 5px;
      font-size: 16px;
      background-color: #4CAF50;
      color: white;
      border: none;
      border-radius: 5px;
      cursor: pointer;
    }
    .btn:hover {
      background-color: #45a049;
    }
    #mathQuestion {
      font-size: 24px;
      font-weight: bold;
      margin: 20px 0;
      min-height: 60px;
    }
    #playerSelector {
      position: absolute;
      top: 110px;
      left: 50%;
      transform: translateX(-50%);
      background-color: rgba(255, 255, 255, 0.8);
      padding: 10px;
      border-radius: 5px;
      z-index: 100;
      text-align: center;
      font-size: 16px;
    }
    .player-option {
      display: inline-block;
      margin: 0 10px;
      cursor: pointer;
    }
    .player-option input {
      margin-right: 5px;
    }
    .confetti-container {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 90;
      pointer-events: none;
    }
    
    /* Mode selector styles */
    #modeSelector {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.8);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 1000;
    }
    
    .mode-card {
      background-color: white;
      border-radius: 10px;
      padding: 20px;
      margin: 10px;
      width: 300px;
      text-align: center;
      cursor: pointer;
      transition: transform 0.3s;
    }
    
    .mode-card:hover {
      transform: scale(1.05);
    }
    
    .mode-icon {
      font-size: 48px;
      margin-bottom: 10px;
    }
    
    /* Multiplayer setup styles */
    #multiplayerSetup {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.8);
      display: none;
      justify-content: center;
      align-items: center;
      z-index: 1000;
      flex-direction: column;
    }
    
    .setup-card {
      background-color: white;
      border-radius: 10px;
      padding: 20px;
      width: 400px;
      text-align: center;
    }
    
    .tabs {
      display: flex;
      justify-content: center;
      margin-bottom: 20px;
    }
    
    .tab {
      padding: 10px 20px;
      background-color: #ddd;
      cursor: pointer;
      border-radius: 5px 5px 0 0;
      margin: 0 5px;
    }
    
    .tab.active {
      background-color: #4CAF50;
      color: white;
    }
    
    .tab-content {
      display: none;
    }
    
    .tab-content.active {
      display: block;
    }
    
    #gameIdDisplay {
      font-size: 24px;
      padding: 10px;
      background-color: #f0f0f0;
      border-radius: 5px;
      margin: 10px 0;
      word-break: break-all;
    }
    
    #copyButton {
      padding: 5px 10px;
      background-color: #4CAF50;
      color: white;
      border: none;
      border-radius: 3px;
      cursor: pointer;
      margin-left: 10px;
    }
    
    #connectionStatus {
      position: absolute;
      top: 10px;
      left: 20px;
      background-color: rgba(255, 255, 255, 0.8);
      padding: 10px;
      border-radius: 5px;
      z-index: 90;
      font-size: 14px;
      display: none;
    }
    
    .status-indicator {
      display: inline-block;
      width: 10px;
      height: 10px;
      border-radius: 50%;
      margin-right: 5px;
    }
    
    .status-connecting {
      background-color: orange;
    }
    
    .status-connected {
      background-color: green;
    }
    
    .status-disconnected {
      background-color: red;
    }
    
    #waitingMessage {
      font-size: 20px;
      margin: 20px 0;
      color: #666;
    }
    
    /* Lobby UI for multiplayer */
    #lobby {
      display: none;
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background-color: rgba(255,255,255,0.9);
      padding: 20px;
      border-radius: 5px;
      z-index: 1100;
      text-align: center;
    }
    
    /* Chat container styles */
    #chatContainer {
      position: absolute;
      bottom: 80px;
      right: 20px;
      width: 300px;
      background-color: rgba(255, 255, 255, 0.9);
      border-radius: 8px;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
      z-index: 150;
      display: flex;
      flex-direction: column;
      overflow: hidden;
      transition: all 0.3s ease;
    }
    
    #chatHeader {
      background-color: #4CAF50;
      color: white;
      padding: 8px 12px;
      font-weight: bold;
      cursor: pointer;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    
    #chatMessages {
      height: 200px;
      overflow-y: auto;
      padding: 10px;
      background-color: #f9f9f9;
    }
    
    .message {
      margin-bottom: 8px;
      padding: 6px 10px;
      border-radius: 8px;
      max-width: 85%;
      word-wrap: break-word;
    }
    
    .message-tati {
      background-color: #ffdddd;
      align-self: flex-start;
      margin-right: auto;
    }
    
    .message-yoni {
      background-color: #ddeeff;
      align-self: flex-end;
      margin-left: auto;
    }
    
    .message-player {
      font-weight: bold;
      font-size: 12px;
      margin-bottom: 2px;
    }
    
    .message-tati .message-player {
      color: #cc0000;
    }
    
    .message-yoni .message-player {
      color: #0066cc;
    }
    
    .message-content {
      font-size: 14px;
    }
    
    #chatInput {
      display: flex;
      border-top: 1px solid #ddd;
    }
    
    #messageInput {
      flex-grow: 1;
      padding: 8px 12px;
      border: none;
      outline: none;
      font-size: 14px;
    }
    
    #sendButton {
      background-color: #4CAF50;
      color: white;
      border: none;
      padding: 8px 15px;
      cursor: pointer;
      font-size: 14px;
    }
    
    #sendButton:hover {
      background-color: #45a049;
    }
    
    #chatToggle {
      margin-right: 5px;
    }
    
    .collapsed #chatMessages,
    .collapsed #chatInput {
      display: none;
    }
    
    /* Responsive styles */
    @media screen and (max-width: 768px) {
      .mode-card {
        width: 250px;
        padding: 15px;
      }
      
      .setup-card {
        width: 90%;
        max-width: 350px;
      }
      
      #info {
        font-size: 16px;
      }
      
      #gameStatus {
        font-size: 20px;
      }
      
      #scoreBoard {
        font-size: 14px;
      }
      
      .btn {
        padding: 8px 16px;
        font-size: 14px;
      }
      
      #chatContainer {
        width: 250px;
        bottom: 70px;
      }
      
      #chatMessages {
        height: 150px;
      }
    }
    
    @media screen and (max-width: 480px) {
      .player-option {
        display: block;
        margin: 10px 0;
      }
      
      .tabs {
        flex-direction: column;
      }
      
      .tab {
        margin: 2px 0;
        border-radius: 5px;
      }
      
      #chatContainer {
        width: 220px;
        bottom: 60px;
        right: 10px;
      }
      
      #chatMessages {
        height: 120px;
      }
    }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.5.1/dist/confetti.browser.min.js"></script>
</head>
<body>
  <!-- Mode Selector Screen -->
  <div id="modeSelector">
    <div class="mode-card" id="singlePcMode">
      <div class="mode-icon">üñ•Ô∏è</div>
      <h2>Single PC Mode</h2>
      <p>Play on this computer, taking turns</p>
    </div>
    <div class="mode-card" id="multiplayerMode">
      <div class="mode-icon">üåê</div>
      <h2>Two PC Mode</h2>
      <p>Play with someone on another computer</p>
    </div>
  </div>
  
  <!-- Multiplayer Setup Screen -->
  <div id="multiplayerSetup">
    <div class="setup-card">
      <h2>Two PC Mode Setup</h2>
      <div class="tabs">
        <div class="tab active" data-tab="create">Create Game</div>
        <div class="tab" data-tab="join">Join Game</div>
      </div>
      
      <div class="tab-content active" id="createGame">
        <p>Create a new game and share the ID with your friend</p>
        <button class="btn" id="generateGameBtn">Generate Game ID</button>
        <div id="gameIdDisplay" style="display:none;"></div>
        <button id="copyButton" style="display:none;">Copy</button>
        <p>You will play as: <span id="creatorRole">TATI (X)</span></p>
        <div id="waitingMessage" style="display:none;">Waiting for opponent to join...</div>
      </div>
      
      <div class="tab-content" id="joinGame">
        <p>Enter the game ID shared by your friend</p>
        <input type="text" id="gameIdInput" placeholder="Game ID" style="width:100%; padding:10px; margin:10px 0;">
        <p>You will play as: <span id="joinerRole">YONI (O)</span></p>
        <button class="btn" id="joinGameBtn">Join Game</button>
      </div>
      
      <div style="margin-top: 20px; text-align: center;">
        <button class="btn" id="cancelSetupBtn" style="background-color: #f44336;">Cancel</button>
      </div>
    </div>
  </div>
  
  <!-- Lobby UI for Multiplayer -->
  <div id="lobby">
    <div id="lobbyMessage">Waiting for opponent to join...</div>
    <button id="lobbyStartBtn" class="btn" style="display:none; margin-top:10px;">Start Game</button>
  </div>
  
  <!-- Connection Status -->
  <div id="connectionStatus">
    <span class="status-indicator status-disconnected"></span>
    <span id="statusText">Disconnected</span>
  </div>
  
  <div id="info">5x5 Tic-Tac-Toe (Connect 4) - X: TATI, O: YONI</div>
  <div id="gameStatus">Select who starts</div>
  <button id="resetButton">Reset Game</button>
  
  <div id="playerSelector">
    <div class="player-option">
      <input type="radio" id="tatiFirst" name="startPlayer" value="X" checked>
      <label for="tatiFirst">TATI starts (X)</label>
    </div>
    <div class="player-option">
      <input type="radio" id="yoniFirst" name="startPlayer" value="O">
      <label for="yoniFirst">YONI starts (O)</label>
    </div>
    <button class="btn" id="startGameBtn">Start Game</button>
  </div>
  
  <div id="scoreBoard">
    <div>TATI (X): <span id="scoreX">0</span> points</div>
    <div>YONI (O): <span id="scoreO">0</span> points</div>
  </div>
  
  <!-- Chat Container -->
  <div id="chatContainer">
    <div id="chatHeader">
      <span>Game Chat</span>
      <span id="chatToggle">-</span>
    </div>
    <div id="chatMessages"></div>
    <div id="chatInput">
      <input type="text" id="messageInput" placeholder="Type a message...">
      <button id="sendButton">Send</button>
    </div>
  </div>
  
  <div id="mathModal">
    <div class="modal-content">
      <h2>Double Your Points!</h2>
      <p>YONI, solve this math problem to double your points:</p>
      <div id="mathQuestion"></div>
      <input type="number" id="answerInput" placeholder="Answer">
      <div>
        <button class="btn" id="submitAnswer">Submit</button>
        <button class="btn" id="skipQuestion" style="background-color: #f44336;">Skip</button>
      </div>
    </div>
  </div>
  
  <div class="confetti-container" id="confettiContainer"></div>
  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script>
    // Game variables
    let scene, camera, renderer;
    let board = [];
    let currentPlayer = 'X';
    let gameOver = false;
    let gameStarted = false;
    let gameMode = 'singlePc'; // 'singlePc' or 'multiplayer'
    const BOARD_SIZE = 5;
    const CELL_SIZE = 1.25; // Increased by 25% from 1.0
    const WINNING_LENGTH = 4;
    const SPACING = 0.1;
    const TOTAL_SIZE = BOARD_SIZE * (CELL_SIZE + SPACING) - SPACING;
    const OFFSET = TOTAL_SIZE / 2 - CELL_SIZE / 2;
    
    // Player names and scores
    const PLAYER_X = "TATI";
    const PLAYER_O = "YONI";
    let scoreX = 0;
    let scoreO = 0;
    
    // Multiplayer variables
    let peer;
    let connection;
    let isHost = false;
    let myPlayerSymbol = null;
    let gameId = '';
    let peerConnected = false;
    
    // Math challenge variables
    let currentAnswer = 0;
    let mathDifficulty = 1; // Start with easy questions
    let consecutiveCorrect = 0;
    let currentMathProblem = null; // Store the current math problem for multiplayer sharing
    
    // Camera settings for stable rendering
    let cameraAngle = 0;
    let cameraHeight = 10; // Increased from 8 to accommodate larger board
    let cameraDistance = 12; // Increased from 8 to accommodate larger board
    let cameraRotationSpeed = 0.001; // Reduced from 0.002 for smoother rotation
    let isCameraAutoRotating = true;
    let lastFrameTime = 0;
    
    // Chat variables
    let chatCollapsed = false;
    
    // Mode Selection
    document.getElementById('singlePcMode').addEventListener('click', () => {
      gameMode = 'singlePc';
      document.getElementById('modeSelector').style.display = 'none';
      initGame();
    });
    
    document.getElementById('multiplayerMode').addEventListener('click', () => {
      gameMode = 'multiplayer';
      document.getElementById('modeSelector').style.display = 'none';
      document.getElementById('multiplayerSetup').style.display = 'flex';
      setupMultiplayerTabs();
    });
    
    // Reset button event listener
    document.getElementById('resetButton').addEventListener('click', resetGame);
    
    // Chat UI event listeners
    document.getElementById('chatHeader').addEventListener('click', toggleChat);
    document.getElementById('sendButton').addEventListener('click', sendChatMessage);
    document.getElementById('messageInput').addEventListener('keypress', (e) => {
      if (e.key === 'Enter') {
        sendChatMessage();
      }
    });
    
    // Toggle chat visibility
    function toggleChat() {
      const chatContainer = document.getElementById('chatContainer');
      const chatToggle = document.getElementById('chatToggle');
      
      chatCollapsed = !chatCollapsed;
      
      if (chatCollapsed) {
        chatContainer.classList.add('collapsed');
        chatToggle.textContent = '+';
      } else {
        chatContainer.classList.remove('collapsed');
        chatToggle.textContent = '-';
      }
    }
    
    // Send chat message
    function sendChatMessage() {
      const messageInput = document.getElementById('messageInput');
      const message = messageInput.value.trim();
      
      if (message === '') return;
      
      const playerSymbol = gameMode === 'multiplayer' ? myPlayerSymbol : currentPlayer;
      const playerName = playerSymbol === 'X' ? PLAYER_X : PLAYER_O;
      
      // Display message in chat
      displayChatMessage(playerName, message, playerSymbol);
      
      // Send message to other player in multiplayer mode
      if (gameMode === 'multiplayer' && connection && connection.open) {
        sendGameMessage({
          type: 'chat',
          player: playerName,
          playerSymbol: playerSymbol,
          message: message
        });
      }
      
      // Clear input field
      messageInput.value = '';
    }
    
    // Display chat message
    function displayChatMessage(playerName, message, playerSymbol) {
      const chatMessages = document.getElementById('chatMessages');
      const messageDiv = document.createElement('div');
      
      messageDiv.className = `message message-${playerName.toLowerCase()}`;
      
      const playerDiv = document.createElement('div');
      playerDiv.className = 'message-player';
      playerDiv.textContent = playerName;
      
      const contentDiv = document.createElement('div');
      contentDiv.className = 'message-content';
      contentDiv.textContent = message;
      
      messageDiv.appendChild(playerDiv);
      messageDiv.appendChild(contentDiv);
      
      chatMessages.appendChild(messageDiv);
      
      // Scroll to bottom
      chatMessages.scrollTop = chatMessages.scrollHeight;
      
      // If chat is collapsed, show it temporarily
      if (chatCollapsed) {
        toggleChat();
        
        // Optional: collapse chat again after a few seconds
        // setTimeout(toggleChat, 5000);
      }
    }
    
    // Multiplayer Setup Tabs
    function setupMultiplayerTabs() {
      const tabs = document.querySelectorAll('.tab');
      tabs.forEach(tab => {
        tab.addEventListener('click', () => {
          document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
          document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
          tab.classList.add('active');
          const tabId = tab.getAttribute('data-tab');
          if (tabId === 'create') {
            document.getElementById('createGame').classList.add('active');
          } else if (tabId === 'join') {
            document.getElementById('joinGame').classList.add('active');
          }
        });
      });
      
      document.getElementById('generateGameBtn').addEventListener('click', createMultiplayerGame);
      document.getElementById('joinGameBtn').addEventListener('click', joinMultiplayerGame);
      document.getElementById('copyButton').addEventListener('click', () => {
        const gameIdText = document.getElementById('gameIdDisplay').textContent;
        navigator.clipboard.writeText(gameIdText).then(() => {
          alert('Game ID copied to clipboard!');
        }).catch(err => {
          console.error('Could not copy text: ', err);
        });
      });
      document.getElementById('cancelSetupBtn').addEventListener('click', () => {
        document.getElementById('gameIdDisplay').style.display = 'none';
        document.getElementById('copyButton').style.display = 'none';
        document.getElementById('waitingMessage').style.display = 'none';
        document.getElementById('generateGameBtn').style.display = 'block';
        document.getElementById('gameIdInput').value = '';
        if (peer) {
          peer.destroy();
          peer = null;
        }
        if (connection) {
          connection.close();
          connection = null;
        }
        document.getElementById('connectionStatus').style.display = 'none';
        document.getElementById('multiplayerSetup').style.display = 'none';
        document.getElementById('modeSelector').style.display = 'flex';
      });
    }
    
    // Create Multiplayer Game (Host)
    function createMultiplayerGame() {
      isHost = true;
      myPlayerSymbol = 'X'; // Host is TATI (X)
      gameId = Math.random().toString(36).substring(2, 10).toUpperCase();
      const gameIdDisplay = document.getElementById('gameIdDisplay');
      gameIdDisplay.textContent = gameId;
      gameIdDisplay.style.display = 'block';
      document.getElementById('copyButton').style.display = 'inline-block';
      document.getElementById('waitingMessage').style.display = 'block';
      document.getElementById('generateGameBtn').style.display = 'none';
      
      // Show lobby UI with game ID info
      document.getElementById('lobby').style.display = 'block';
      document.getElementById('lobbyMessage').textContent = "Waiting for opponent to join with ID: " + gameId;
      document.getElementById('lobbyStartBtn').style.display = 'none';
      
      // Initialize PeerJS with the game ID
      initPeer(gameId);
      
      // Initialize game scene (but do not start the game yet)
      initGame();
      
      // Hide player selector in multiplayer
      document.getElementById('playerSelector').style.display = 'none';
      
      // Update game status text for host
      document.getElementById('gameStatus').textContent = "Lobby open. Waiting for opponent...";
      
      // Add system message to chat
      displayChatMessage("System", "You've created a game as TATI (X). Waiting for opponent to join...", "system");
      
      console.log("Created multiplayer game with ID:", gameId);
    }
    
    // Join Multiplayer Game (Joiner)
    function joinMultiplayerGame() {
      isHost = false;
      myPlayerSymbol = 'O'; // Joiner is YONI (O)
      gameId = document.getElementById('gameIdInput').value.trim();
      if (!gameId) {
        alert('Please enter a valid Game ID');
        return;
      }
      // Initialize PeerJS and connect to host
      initPeer();
      
      // Initialize game scene (do not start until host clicks Start)
      initGame();
      gameStarted = false;
      currentPlayer = 'X';
      updateGameStatus();
      document.getElementById('playerSelector').style.display = 'none';
      document.getElementById('gameStatus').textContent = "Waiting for host to start game...";
      
      // Show lobby UI for joiner
      document.getElementById('lobby').style.display = 'block';
      document.getElementById('lobbyMessage').textContent = "Connecting to host...";
      document.getElementById('lobbyStartBtn').style.display = 'none';
      
      // Add system message to chat
      displayChatMessage("System", "You're joining a game as YONI (O). Connecting to host...", "system");
      
      console.log("Join multiplayer game with ID:", gameId);
    }
    
    // Initialize PeerJS with immediate connection listener for host
    function initPeer(id = null) {
      try {
        updateConnectionStatus('connecting', 'Initializing connection...');
        peer = new Peer(id);
        
        peer.on('open', (id) => {
          console.log('My peer ID is: ' + id);
          updateConnectionStatus('connecting', isHost ? 'Waiting for opponent...' : 'Connecting to game...');
          
          // If joiner, connect to host after peer is open
          if (!isHost) {
            connectToPeer(gameId);
          }
        });
        
        if (isHost) {
          peer.on('connection', (conn) => {
            console.log("Received connection from peer");
            connection = conn;
            setupConnectionHandlers();
          });
        }
        
        peer.on('error', (err) => {
          console.error('PeerJS error:', err);
          updateConnectionStatus('disconnected', 'Connection error: ' + err.type);
          alert('Connection error: ' + err.message);
        });
      } catch (error) {
        console.error("Error initializing PeerJS:", error);
        alert("Error setting up multiplayer: " + error.message);
      }
    }
    
    // Connect to peer (for joiner)
    function connectToPeer(peerId) {
      try {
        console.log("Connecting to peer:", peerId);
        connection = peer.connect(peerId);
        setupConnectionHandlers();
      } catch (error) {
        console.error("Error connecting to peer:", error);
        alert("Error connecting to game: " + error.message);
      }
    }
    
    // Setup connection event handlers
    function setupConnectionHandlers() {
      if (!connection) {
        console.error("No connection object available");
        return;
      }
      
      connection.on('open', () => {
        console.log('Connected to peer!');
        peerConnected = true;
        updateConnectionStatus('connected', 'Connected to opponent');
        
        // Send initial hello message
        sendGameMessage({
          type: 'hello',
          player: myPlayerSymbol
        });
        
        // Add system message to chat
        displayChatMessage("System", "Connected to opponent!", "system");
        
        // For host, update lobby UI to allow game start
        if (isHost) {
          document.getElementById('lobbyMessage').textContent = "Opponent joined! Click Start to begin.";
          document.getElementById('lobbyStartBtn').style.display = 'inline-block';
          
          // Ensure the Start button has an event listener
          document.getElementById('lobbyStartBtn').onclick = function() {
            startMultiplayerGame();
          };
          
          // Enable reset button for host
          document.getElementById('resetButton').style.display = 'block';
        } else {
          document.getElementById('lobbyMessage').textContent = "Connected to host. Waiting for game to start...";
          
          // Hide reset button for non-host players
          document.getElementById('resetButton').style.display = 'none';
        }
      });
      
      connection.on('data', (data) => {
        console.log('Received data:', data);
        handleGameMessage(data);
      });
      
      connection.on('close', () => {
        console.log('Connection closed');
        peerConnected = false;
        updateConnectionStatus('disconnected', 'Connection closed');
        displayChatMessage("System", "Connection to opponent lost", "system");
        alert('Connection to opponent lost.');
      });
      
      connection.on('error', (err) => {
        console.error('Connection error:', err);
        peerConnected = false;
        updateConnectionStatus('disconnected', 'Connection error');
      });
    }
    
    // Send game message to peer
    function sendGameMessage(message) {
      if (connection && connection.open) {
        console.log('Sending message:', message);
        connection.send(message);
      } else {
        console.warn("Cannot send message - connection not open", message);
      }
    }
    
    // Handle incoming game messages
    function handleGameMessage(message) {
      console.log('Processing message:', message);
      switch (message.type) {
        case 'hello':
          console.log('Opponent is player:', message.player);
          // For host, make sure to update lobby UI when hello is received
          if (isHost) {
            document.getElementById('lobbyMessage').textContent = "Opponent joined! Click Start to begin.";
            document.getElementById('lobbyStartBtn').style.display = 'inline-block';
          }
          break;
        case 'move':
          if (gameMode === 'multiplayer' && message.player !== myPlayerSymbol) {
            console.log('Processing opponent move:', message.row, message.col);
            placeMark(message.row, message.col, true);
          }
          break;
        case 'reset':
          if (gameMode === 'multiplayer' && !isHost) {
            console.log('Resetting game from peer message');
            resetGameFromMessage();
          }
          break;
        case 'score_update':
          console.log('Updating scores from peer message');
          scoreX = message.scoreX;
          scoreO = message.scoreO;
          updateScoreDisplay();
          break;
        case 'chat':
          console.log('Received chat message:', message);
          // Display the message from the other player
          displayChatMessage(message.player, message.message, message.playerSymbol);
          break;
        case 'start':
          console.log('Start game signal received.');
          gameStarted = true;
          currentPlayer = 'X';
          updateGameStatus();
          // Add system message to chat
          displayChatMessage("System", "Game started!", "system");
          // Hide all setup and lobby UI elements for joiner
          document.getElementById('lobby').style.display = 'none';
          document.getElementById('multiplayerSetup').style.display = 'none';
          break;
        case 'stop_camera':
          console.log('Stopping camera rotation');
          isCameraAutoRotating = false;
          break;
        case 'start_camera':
          console.log('Starting camera rotation');
          isCameraAutoRotating = true;
          break;
        case 'math_challenge':
          console.log('Received math challenge:', message);
          if (myPlayerSymbol === 'O') {
            // Only show math challenge to YONI player (O)
            currentMathProblem = {
              question: message.question,
              answer: message.answer
            };
            currentAnswer = message.answer;
            document.getElementById('mathQuestion').textContent = message.question;
            document.getElementById('answerInput').value = '';
            document.getElementById('mathModal').style.display = 'flex';
          }
          break;
        case 'math_result':
          console.log('Received math result:', message);
          if (myPlayerSymbol === 'X') {
            // Host (X) receives the result of the math challenge
            scoreX = message.scoreX;
            scoreO = message.scoreO;
            updateScoreDisplay();
            saveGame();
            
            // Display message about the result
            if (message.success) {
              displayChatMessage("System", "YONI solved the math problem correctly and doubled points!", "system");
            } else if (message.skipped) {
              displayChatMessage("System", "YONI skipped the math challenge.", "system");
            } else {
              displayChatMessage("System", `YONI got the math problem wrong. The correct answer was ${message.correctAnswer}.`, "system");
            }
          }
          break;
        default:
          console.warn('Unknown message type:', message.type);
          break;
      }
    }
    
    // Update connection status display
    function updateConnectionStatus(status, message) {
      const statusElem = document.getElementById('connectionStatus');
      const indicator = statusElem.querySelector('.status-indicator');
      const text = document.getElementById('statusText');
      statusElem.style.display = 'block';
      indicator.classList.remove('status-connecting', 'status-connected', 'status-disconnected');
      indicator.classList.add('status-' + status);
      text.textContent = message;
      console.log('Connection status:', status, message);
    }
    
    // Load saved scores from local storage (for single PC mode)
    function loadSavedGame() {
      if (localStorage.getItem('tictactoeScores')) {
        const savedData = JSON.parse(localStorage.getItem('tictactoeScores'));
        scoreX = savedData.scoreX || 0;
        scoreO = savedData.scoreO || 0;
        mathDifficulty = savedData.mathDifficulty || 1;
        consecutiveCorrect = savedData.consecutiveCorrect || 0;
        updateScoreDisplay();
      }
    }
    
    // Save game state to local storage
    function saveGame() {
      const gameData = {
        scoreX: scoreX,
        scoreO: scoreO,
        mathDifficulty: mathDifficulty,
        consecutiveCorrect: consecutiveCorrect
      };
      localStorage.setItem('tictactoeScores', JSON.stringify(gameData));
      if (gameMode === 'multiplayer' && connection && connection.open) {
        sendGameMessage({
          type: 'score_update',
          scoreX: scoreX,
          scoreO: scoreO
        });
      }
    }
    
    // Initialize the scene
    function initGame() {
      console.log("Initializing game in mode:", gameMode);
      if (gameMode === 'singlePc') {
        loadSavedGame();
        // Show reset button for single PC mode
        document.getElementById('resetButton').style.display = 'block';
        // Clear and initialize chat for single PC mode
        document.getElementById('chatMessages').innerHTML = '';
        displayChatMessage("System", "Single PC Mode - Players can chat during the game", "system");
      } else {
        document.getElementById('connectionStatus').style.display = 'block';
        // In multiplayer mode, only show reset button for host
        document.getElementById('resetButton').style.display = isHost ? 'block' : 'none';
        // Clear chat for multiplayer mode
        document.getElementById('chatMessages').innerHTML = '';
      }
      
      // Setup 3D scene
      setupScene();
      
      // Add event listeners for user interactions
      window.addEventListener('resize', onWindowResize, false);
      document.addEventListener('mousedown', onMouseDown, false);
      document.addEventListener('keydown', onKeyDown, false);
      document.getElementById('submitAnswer').addEventListener('click', checkMathAnswer);
      document.getElementById('skipQuestion').addEventListener('click', skipMathQuestion);
      
      if (gameMode === 'singlePc') {
        document.getElementById('startGameBtn').addEventListener('click', startGame);
        document.getElementById('playerSelector').style.display = 'block';
      } else {
        // In multiplayer mode, lobby UI is used instead of playerSelector
        document.getElementById('playerSelector').style.display = 'none';
      }
      
      animate();
    }
    
    // Setup the 3D scene
    function setupScene() {
      // Clean up any existing scene
      if (renderer && renderer.domElement && renderer.domElement.parentNode) {
        renderer.domElement.parentNode.removeChild(renderer.domElement);
      }
      
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0xf0f0f0);
      
      // Camera setup with better initialization for larger board
      camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
      camera.position.set(0, cameraHeight, cameraDistance);
      camera.lookAt(0, 0, 0);
      
      // Renderer with antialiasing for smoother graphics
      renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(window.devicePixelRatio);
      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = THREE.PCFSoftShadowMap;
      document.body.appendChild(renderer.domElement);
      
      // Improved lighting for better visual quality
      const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
      scene.add(ambientLight);
      
      const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
      directionalLight.position.set(5, 10, 5);
      directionalLight.castShadow = true;
      
      // Improve shadow quality
      directionalLight.shadow.mapSize.width = 1024;
      directionalLight.shadow.mapSize.height = 1024;
      directionalLight.shadow.camera.near = 0.5;
      directionalLight.shadow.camera.far = 50;
      directionalLight.shadow.bias = -0.001;
      
      scene.add(directionalLight);
      
      // Add a subtle fill light from the opposite side
      const fillLight = new THREE.DirectionalLight(0xffffff, 0.3);
      fillLight.position.set(-5, 5, -5);
      scene.add(fillLight);
      
      // Board base with improved materials
      const baseGeometry = new THREE.BoxGeometry(TOTAL_SIZE + 0.5, 0.2, TOTAL_SIZE + 0.5);
      const baseMaterial = new THREE.MeshStandardMaterial({ 
        color: 0x555555,
        roughness: 0.7,
        metalness: 0.1
      });
      const base = new THREE.Mesh(baseGeometry, baseMaterial);
      base.position.y = -0.15;
      base.receiveShadow = true;
      scene.add(base);
      
      createGrid();
    }
    
    // Start game function for single PC mode (used only in that mode)
    function startGame() {
      if (gameStarted) return;
      gameStarted = true;
      const selectedPlayer = document.querySelector('input[name="startPlayer"]:checked').value;
      currentPlayer = selectedPlayer;
      document.getElementById('playerSelector').style.display = 'none';
      updateGameStatus();
      
      // Add system message to chat
      const startingPlayer = currentPlayer === 'X' ? PLAYER_X : PLAYER_O;
      displayChatMessage("System", `Game started with ${startingPlayer} (${currentPlayer}) playing first`, "system");
    }
    
    // Start Multiplayer Game (Host clicking Start in lobby)
    function startMultiplayerGame() {
      console.log("Starting multiplayer game (host)");
      // Host triggers game start only after opponent has joined
      gameStarted = true;
      currentPlayer = 'X'; // Host (TATI) always starts as X
      updateGameStatus();
      
      // Add system message to chat
      displayChatMessage("System", "Game started! TATI (X) plays first", "system");
      
      // Hide all setup and lobby UI elements
      document.getElementById('lobby').style.display = 'none';
      document.getElementById('multiplayerSetup').style.display = 'none';
      
      // Send start signal to joiner
      sendGameMessage({ type: 'start' });
    }
    
    // Create the grid with improved cell rendering
    function createGrid() {
      board = Array(BOARD_SIZE).fill().map(() => Array(BOARD_SIZE).fill(null));
      
      // Create a group for all grid cells for better organization
      const gridGroup = new THREE.Group();
      scene.add(gridGroup);
      
      // Create the grid cells with improved rendering
      for (let i = 0; i < BOARD_SIZE; i++) {
        for (let j = 0; j < BOARD_SIZE; j++) {
          // Create a visible cell with better materials
          const cellGeometry = new THREE.BoxGeometry(CELL_SIZE, 0.1, CELL_SIZE);
          const cellMaterial = new THREE.MeshStandardMaterial({ 
            color: 0xffffff,
            transparent: true,
            opacity: 0.9,
            roughness: 0.3,
            metalness: 0.1
          });
          
          const cell = new THREE.Mesh(cellGeometry, cellMaterial);
          const x = i * (CELL_SIZE + SPACING) - OFFSET;
          const z = j * (CELL_SIZE + SPACING) - OFFSET;
          cell.position.set(x, 0, z);
          cell.receiveShadow = true;
          
          // Add a subtle shadow and border effect
          const borderGeometry = new THREE.BoxGeometry(CELL_SIZE + 0.05, 0.05, CELL_SIZE + 0.05);
          const borderMaterial = new THREE.MeshStandardMaterial({
            color: 0x888888,
            transparent: true,
            opacity: 0.5
          });
          const border = new THREE.Mesh(borderGeometry, borderMaterial);
          border.position.y = -0.08;
          border.receiveShadow = true;
          cell.add(border);
          
          // Add cell highlight effect for better visual feedback
          const highlightGeometry = new THREE.PlaneGeometry(CELL_SIZE, CELL_SIZE);
          const highlightMaterial = new THREE.MeshBasicMaterial({
            color: 0xffff00,
            transparent: true,
            opacity: 0.0,
            side: THREE.DoubleSide
          });
          const highlight = new THREE.Mesh(highlightGeometry, highlightMaterial);
          highlight.rotation.x = -Math.PI / 2;
          highlight.position.y = 0.055;
          highlight.userData = { type: 'highlight', row: i, col: j };
          cell.add(highlight);
          
          gridGroup.add(cell);
          
          // Add an invisible, larger plane for better click detection
          const clickGeometry = new THREE.PlaneGeometry(CELL_SIZE, CELL_SIZE);
          const clickMaterial = new THREE.MeshBasicMaterial({ 
            color: 0x000000,
            transparent: true,
            opacity: 0.0,
            side: THREE.DoubleSide
          });
          const clickMesh = new THREE.Mesh(clickGeometry, clickMaterial);
          clickMesh.rotation.x = -Math.PI / 2;
          clickMesh.position.set(x, 0.05, z);
          clickMesh.userData = { row: i, col: j, type: 'cell' };
          scene.add(clickMesh);
        }
      }
    }
    
    // Update game status display
    function updateGameStatus() {
      const playerName = currentPlayer === 'X' ? PLAYER_X : PLAYER_O;
      if (gameMode === 'multiplayer') {
        if (currentPlayer === myPlayerSymbol) {
          document.getElementById('gameStatus').textContent = `Your turn (${currentPlayer})`;
        } else {
          document.getElementById('gameStatus').textContent = `Opponent's turn (${currentPlayer})`;
        }
      } else {
        document.getElementById('gameStatus').textContent = `${playerName}'s turn (${currentPlayer})`;
      }
    }
    
    // Update score display
    function updateScoreDisplay() {
      document.getElementById('scoreX').textContent = scoreX;
      document.getElementById('scoreO').textContent = scoreO;
    }
    
    // Trigger confetti effect
    function triggerConfetti(winner) {
      const colors = winner === 'X' ? ['#ff0000', '#ff3333', '#ff6666'] : ['#0000ff', '#3333ff', '#6666ff'];
      confetti({
        particleCount: 150,
        spread: 100,
        origin: { y: 0.6 },
        colors: colors
      });
      setTimeout(() => {
        confetti({
          particleCount: 80,
          angle: 60,
          spread: 55,
          origin: { x: 0, y: 0.6 },
          colors: colors
        });
      }, 200);
      setTimeout(() => {
        confetti({
          particleCount: 80,
          angle: 120,
          spread: 55,
          origin: { x: 1, y: 0.6 },
          colors: colors
        });
      }, 400);
    }
    
    // Make losing pieces fall animation
    function makeLosingPiecesFall(loser) {
      scene.traverse((object) => {
        if (object.userData && object.userData.type === 'mark' && object.userData.player === loser) {
          object.userData.falling = true;
          object.userData.fallSpeed = 0.02 + Math.random() * 0.03; // Randomized fall speed
          object.userData.rotationSpeed = {
            x: (Math.random() - 0.5) * 0.1,
            y: (Math.random() - 0.5) * 0.1,
            z: (Math.random() - 0.5) * 0.1
          };
        }
      });
    }
    
    // Place a mark on the board with improved visual effects
    function placeMark(row, col, fromOpponent = false) {
      if (gameMode === 'multiplayer') {
        if (!fromOpponent && currentPlayer !== myPlayerSymbol) {
          return;
        }
      }
      if (!gameStarted || gameOver || board[row][col] !== null) return;
      board[row][col] = currentPlayer;
      if (gameMode === 'multiplayer' && !fromOpponent) {
        sendGameMessage({
          type: 'move',
          player: myPlayerSymbol,
          row: row,
          col: col
        });
      }
      
      // Create mark with improved visuals
      let markObject;
      const x = row * (CELL_SIZE + SPACING) - OFFSET;
      const z = col * (CELL_SIZE + SPACING) - OFFSET;
      
      if (currentPlayer === 'X') {
        // Create a more visually appealing X mark
        const group = new THREE.Group();
        
        // Thicker bars for X
        const xBar1Geometry = new THREE.BoxGeometry(0.15, 0.2, CELL_SIZE * 0.7);
        const xBar2Geometry = new THREE.BoxGeometry(0.15, 0.2, CELL_SIZE * 0.7);
        
        const xMaterial = new THREE.MeshStandardMaterial({ 
          color: 0xff0000,
          roughness: 0.3,
          metalness: 0.5,
          emissive: 0x330000
        });
        
        const xMesh1 = new THREE.Mesh(xBar1Geometry, xMaterial);
        const xMesh2 = new THREE.Mesh(xBar2Geometry, xMaterial);
        
        xMesh1.rotation.y = Math.PI / 4;
        xMesh2.rotation.y = -Math.PI / 4;
        
        xMesh1.castShadow = true;
        xMesh2.castShadow = true;
        
        group.add(xMesh1);
        group.add(xMesh2);
        
        // Add a small animation for placement
        group.scale.set(0.01, 0.01, 0.01);
        group.userData = { 
          type: 'mark', 
          player: currentPlayer, 
          row, 
          col,
          animating: true,
          animationProgress: 0
        };
        
        markObject = group;
      } else {
        // Create a more visually appealing O mark
        const torusGeometry = new THREE.TorusGeometry(CELL_SIZE * 0.3, CELL_SIZE * 0.08, 20, 36);
        const torusMaterial = new THREE.MeshStandardMaterial({ 
          color: 0x0000ff,
          roughness: 0.3,
          metalness: 0.5,
          emissive: 0x000033
        });
        
        const torus = new THREE.Mesh(torusGeometry, torusMaterial);
        torus.rotation.x = Math.PI / 2;
        torus.castShadow = true;
        
        // Add a small animation for placement
        torus.scale.set(0.01, 0.01, 0.01);
        torus.userData = { 
          type: 'mark', 
          player: currentPlayer, 
          row, 
          col,
          animating: true,
          animationProgress: 0
        };
        
        markObject = torus;
      }
      
      markObject.position.set(x, 0.2, z);
      scene.add(markObject);
      
      // Check for winner after placing mark
      if (checkWinner(row, col)) {
        gameOver = true;
        const winner = currentPlayer === 'X' ? PLAYER_X : PLAYER_O;
        // Determine the loser (the opposite symbol)
        const loser = currentPlayer === 'X' ? 'O' : 'X';
        
        if (gameMode === 'multiplayer') {
          if (currentPlayer === myPlayerSymbol) {
            document.getElementById('gameStatus').textContent = `You win!`;
            // Add chat message
            displayChatMessage("System", "You won the game! üéâ", "system");
          } else {
            document.getElementById('gameStatus').textContent = `Opponent wins!`;
            // Add chat message
            displayChatMessage("System", "Opponent won the game!", "system");
          }
        } else {
          document.getElementById('gameStatus').textContent = `${winner} wins!`;
          // Add chat message
          displayChatMessage("System", `${winner} wins the game! üéâ`, "system");
        }
        triggerConfetti(currentPlayer);
        
        // Make the losing pieces fall
        makeLosingPiecesFall(loser);
        
        if (currentPlayer === 'X') {
          scoreX += 10;
          scoreO = Math.max(0, scoreO - 5);
          updateScoreDisplay();
          saveGame();
        } else {
          scoreO += 10;
          updateScoreDisplay();
          saveGame();
          
          // Show math question for YONI (O) 
          // In single PC mode, show it directly
          if (gameMode === 'singlePc') {
            setTimeout(showMathQuestion, 1500);
          } 
          // In multiplayer mode, host (X) generates and sends the question to YONI (O)
          else if (gameMode === 'multiplayer') {
            if (isHost) {
              setTimeout(() => {
                const mathProblem = generateMathQuestion();
                currentMathProblem = mathProblem;
                // Send math challenge to the opponent
                sendGameMessage({
                  type: 'math_challenge',
                  question: mathProblem.question,
                  answer: mathProblem.answer
                });
                // Add chat message
                displayChatMessage("System", "Sent a math challenge to YONI (O)", "system");
              }, 1500);
            }
          }
        }
        highlightWinningCells();
      } else if (isBoardFull()) {
        gameOver = true;
        document.getElementById('gameStatus').textContent = "It's a draw!";
        // Add chat message
        displayChatMessage("System", "Game ended in a draw!", "system");
        scoreX += 2;
        scoreO += 2;
        updateScoreDisplay();
        saveGame();
      } else {
        currentPlayer = currentPlayer === 'X' ? 'O' : 'X';
        updateGameStatus();
      }
    }
    
    // Generate a basic math question
    function generateBasicMathQuestion() {
      const operations = ['+', '-', '*'];
      let num1, num2, operation, answer;
      if (mathDifficulty === 1) {
        operation = operations[Math.floor(Math.random() * 2)];
        num1 = Math.floor(Math.random() * 20) + 1;
        num2 = operation === '-' ? Math.floor(Math.random() * num1) + 1 : Math.floor(Math.random() * 20) + 1;
      } else if (mathDifficulty === 2) {
        operation = operations[Math.floor(Math.random() * 3)];
        if (operation === '*') {
          num1 = Math.floor(Math.random() * 10) + 1;
          num2 = Math.floor(Math.random() * 10) + 1;
        } else {
          num1 = Math.floor(Math.random() * 50) + 1;
          num2 = operation === '-' ? Math.floor(Math.random() * num1) + 1 : Math.floor(Math.random() * 50) + 1;
        }
      } else {
        operation = operations[Math.floor(Math.random() * 3)];
        if (operation === '*') {
          num1 = Math.floor(Math.random() * 12) + 1;
          num2 = Math.floor(Math.random() * 12) + 1;
        } else {
          num1 = Math.floor(Math.random() * 100) + 1;
          num2 = operation === '-' ? Math.floor(Math.random() * num1) + 1 : Math.floor(Math.random() * 100) + 1;
        }
      }
      switch (operation) {
        case '+': answer = num1 + num2; break;
        case '-': answer = num1 - num2; break;
        case '*': answer = num1 * num2; break;
      }
      return {
        question: `${num1} ${operation} ${num2} = ?`,
        answer: answer,
        type: 'basic'
      };
    }
    
    // Generate a word problem
    function generateWordProblem() {
      const problemTypes = [
        'apples', 'cookies', 'books', 'toys', 'stickers',
        'cards', 'pencils', 'marbles', 'stamps', 'balloons'
      ];
      const itemType = problemTypes[Math.floor(Math.random() * problemTypes.length)];
      let num1, num2, answer, question;
      const operation = Math.floor(Math.random() * 3);
      switch(operation) {
        case 0:
          num1 = Math.floor(Math.random() * (mathDifficulty * 20)) + 1;
          num2 = Math.floor(Math.random() * (mathDifficulty * 20)) + 1;
          question = `YONI has ${num1} ${itemType}. TATI gives her ${num2} more ${itemType}. How many ${itemType} does YONI have now?`;
          answer = num1 + num2;
          break;
        case 1:
          num1 = Math.floor(Math.random() * (mathDifficulty * 30)) + (mathDifficulty * 10);
          num2 = Math.floor(Math.random() * num1) + 1;
          question = `YONI has ${num1} ${itemType}. She gives ${num2} ${itemType} to TATI. How many ${itemType} does YONI have left?`;
          answer = num1 - num2;
          break;
        case 2:
          if (mathDifficulty === 1) {
            num1 = Math.floor(Math.random() * 5) + 1;
            num2 = Math.floor(Math.random() * 5) + 1;
          } else if (mathDifficulty === 2) {
            num1 = Math.floor(Math.random() * 10) + 1;
            num2 = Math.floor(Math.random() * 10) + 1;
          } else {
            num1 = Math.floor(Math.random() * 12) + 1;
            num2 = Math.floor(Math.random() * 12) + 1;
          }
          question = `YONI has ${num1} bags of ${itemType}. Each bag has ${num2} ${itemType}. How many ${itemType} does YONI have in total?`;
          answer = num1 * num2;
          break;
      }
      return {
        question,
        answer,
        type: 'word'
      };
    }
    
    // Generate a missing number problem
    function generateMissingNumberProblem() {
      const operations = ['+', '-', '*'];
      let num1, num2, answer, missingPosition, question;
      const operation = operations[Math.floor(Math.random() * (mathDifficulty < 3 ? 2 : 3))];
      if (operation === '*') {
        num1 = Math.floor(Math.random() * (mathDifficulty * 4)) + 1;
        num2 = Math.floor(Math.random() * (mathDifficulty * 4)) + 1;
      } else {
        num1 = Math.floor(Math.random() * (mathDifficulty * 30)) + 1;
        num2 = operation === '-' ? Math.floor(Math.random() * num1) + 1 : Math.floor(Math.random() * (mathDifficulty * 30)) + 1;
      }
      switch (operation) {
        case '+': answer = num1 + num2; break;
        case '-': answer = num1 - num2; break;
        case '*': answer = num1 * num2; break;
      }
      missingPosition = Math.floor(Math.random() * 3);
      if (missingPosition === 0) {
        question = `? ${operation} ${num2} = ${answer}`;
        answer = num1;
      } else if (missingPosition === 1) {
        question = `${num1} ${operation} ? = ${answer}`;
        answer = num2;
      } else {
        question = `${num1} ${operation} ${num2} = ?`;
      }
      return {
        question,
        answer,
        type: 'missing'
      };
    }
    
    // Generate a multi-step problem (harder)
    function generateMultiStepProblem() {
      let num1, num2, num3, answer, question;
      if (mathDifficulty === 3) {
        num1 = Math.floor(Math.random() * 20) + 1;
        num2 = Math.floor(Math.random() * 20) + 1;
        num3 = Math.floor(Math.random() * 10) + 1;
        const problemType = Math.floor(Math.random() * 3);
        switch(problemType) {
          case 0:
            question = `${num1} + ${num2} √ó ${num3} = ?`;
            answer = num1 + (num2 * num3);
            break;
          case 1:
            if (num1 >= num2) {
              question = `${num1} - ${num2} + ${num3} = ?`;
              answer = num1 - num2 + num3;
            } else {
              question = `${num2} - ${num1} + ${num3} = ?`;
              answer = num2 - num1 + num3;
            }
            break;
          case 2:
            question = `(${num1} + ${num2}) √ó ${num3} = ?`;
            answer = (num1 + num2) * num3;
            break;
        }
      } else {
        num1 = Math.floor(Math.random() * 10) + 1;
        num2 = Math.floor(Math.random() * 10) + 1;
        num3 = Math.floor(Math.random() * 10) + 1;
        const problemType = Math.floor(Math.random() * 2);
        switch(problemType) {
          case 0:
            question = `${num1} + ${num2} + ${num3} = ?`;
            answer = num1 + num2 + num3;
            break;
          case 1:
            if (num1 + num2 >= num3) {
              question = `${num1} + ${num2} - ${num3} = ?`;
              answer = num1 + num2 - num3;
            } else {
              question = `${num3} - ${num1} - ${num2} = ?`;
              answer = num3 - num1 - num2;
            }
            break;
        }
      }
      return {
        question,
        answer,
        type: 'multi'
      };
    }
    
    // Generate a math question based on current difficulty
    function generateMathQuestion() {
      let questionType;
      if (mathDifficulty === 1) {
        questionType = Math.random() < 0.7 ? 'basic' : 'word';
      } else if (mathDifficulty === 2) {
        const rand = Math.random();
        if (rand < 0.4) questionType = 'basic';
        else if (rand < 0.7) questionType = 'word';
        else if (rand < 0.9) questionType = 'missing';
        else questionType = 'multi';
      } else {
        const rand = Math.random();
        if (rand < 0.25) questionType = 'basic';
        else if (rand < 0.5) questionType = 'word';
        else if (rand < 0.75) questionType = 'missing';
        else questionType = 'multi';
      }
      switch (questionType) {
        case 'basic': return generateBasicMathQuestion();
        case 'word': return generateWordProblem();
        case 'missing': return generateMissingNumberProblem();
        case 'multi': return generateMultiStepProblem();
        default: return generateBasicMathQuestion();
      }
    }
    
    // Show math question modal
    function showMathQuestion() {
      const mathProblem = generateMathQuestion();
      document.getElementById('mathQuestion').textContent = mathProblem.question;
      currentAnswer = mathProblem.answer;
      document.getElementById('answerInput').value = '';
      document.getElementById('mathModal').style.display = 'flex';
    }
    
    // Check math answer
    function checkMathAnswer() {
      const userAnswer = parseInt(document.getElementById('answerInput').value);
      let success = false;
      
      if (userAnswer === currentAnswer) {
        scoreO += 10;
        updateScoreDisplay();
        consecutiveCorrect++;
        if (consecutiveCorrect >= 3 && mathDifficulty < 3) {
          mathDifficulty++;
          consecutiveCorrect = 0;
          alert("Correct! Your points have been doubled! The math challenges will now get a bit harder!");
          displayChatMessage("System", "YONI solved the math problem correctly and doubled points! Math difficulty increased.", "system");
        } else {
          alert("Correct! Your points have been doubled!");
          displayChatMessage("System", "YONI solved the math problem correctly and doubled points!", "system");
        }
        success = true;
      } else {
        consecutiveCorrect = 0;
        alert("Sorry, that's incorrect. The correct answer is " + currentAnswer);
        displayChatMessage("System", `YONI got the math problem wrong. The correct answer was ${currentAnswer}.`, "system");
        if (mathDifficulty > 1 && Math.random() < 0.3) {
          mathDifficulty--;
        }
      }
      
      document.getElementById('mathModal').style.display = 'none';
      
      // In multiplayer mode, send result back to host
      if (gameMode === 'multiplayer' && !isHost) {
        sendGameMessage({
          type: 'math_result',
          success: success,
          skipped: false,
          scoreO: scoreO,
          scoreX: scoreX,
          correctAnswer: currentAnswer
        });
      } else {
        saveGame();
      }
    }
    
    // Skip math question
    function skipMathQuestion() {
      document.getElementById('mathModal').style.display = 'none';
      displayChatMessage("System", "YONI skipped the math challenge.", "system");
      
      // In multiplayer mode, send result back to host
      if (gameMode === 'multiplayer' && !isHost) {
        sendGameMessage({
          type: 'math_result',
          success: false,
          skipped: true,
          scoreO: scoreO,
          scoreX: scoreX,
          correctAnswer: currentAnswer
        });
      }
    }
    
    // Check if there's a winner
    function checkWinner(row, col) {
      const directions = [
        [0, 1],
        [1, 0],
        [1, 1],
        [1, -1]
      ];
      for (const [dx, dy] of directions) {
        let count = 1;
        for (let i = 1; i < WINNING_LENGTH; i++) {
          const newRow = row + dx * i;
          const newCol = col + dy * i;
          if (isValidCell(newRow, newCol) && board[newRow][newCol] === currentPlayer) {
            count++;
          } else {
            break;
          }
        }
        for (let i = 1; i < WINNING_LENGTH; i++) {
          const newRow = row - dx * i;
          const newCol = col - dy * i;
          if (isValidCell(newRow, newCol) && board[newRow][newCol] === currentPlayer) {
            count++;
          } else {
            break;
          }
        }
        if (count >= WINNING_LENGTH) {
          return true;
        }
      }
      return false;
    }
    
    // Check if the cell is valid
    function isValidCell(row, col) {
      return row >= 0 && row < BOARD_SIZE && col >= 0 && col < BOARD_SIZE;
    }
    
    // Check if the board is full
    function isBoardFull() {
      for (let i = 0; i < BOARD_SIZE; i++) {
        for (let j = 0; j < BOARD_SIZE; j++) {
          if (board[i][j] === null) {
            return false;
          }
        }
      }
      return true;
    }
    
    // Highlight winning cells
    function highlightWinningCells() {
      // More advanced winning animation with color changes and pulsing
      const winningAnimation = () => {
        const time = Date.now() * 0.001;
        scene.traverse((object) => {
          if (object.userData && object.userData.type === 'mark' && object.userData.player === currentPlayer) {
            if (object.userData.player === 'X') {
              // Rotating X pieces
              object.rotation.y += 0.02;
              object.position.y = 0.2 + Math.sin(time * 3) * 0.1;
              
              // Color pulsing for X pieces
              if (object.children && object.children.length > 0) {
                object.children.forEach(child => {
                  if (child.material) {
                    const intensity = 0.5 + Math.sin(time * 5) * 0.3;
                    child.material.emissive.setRGB(intensity, 0, 0);
                  }
                });
              }
            } else {
              // Rotating O pieces
              object.rotation.z += 0.02;
              object.position.y = 0.2 + Math.sin(time * 3) * 0.1;
              
              // Color pulsing for O pieces
              if (object.material) {
                const intensity = 0.5 + Math.sin(time * 5) * 0.3;
                object.material.emissive.setRGB(0, 0, intensity);
              }
            }
          }
        });
        if (gameOver) {
          requestAnimationFrame(winningAnimation);
        }
      };
      winningAnimation();
    }
    
    // Reset the game
    function resetGame() {
      try {
        // Only allow host to reset in multiplayer mode
        if (gameMode === 'multiplayer' && !isHost) {
          alert("Only the host can reset the game.");
          return;
        }
        
        const objectsToRemove = [];
        scene.traverse((object) => {
          if (object.userData && object.userData.type === 'mark') {
            objectsToRemove.push(object);
          }
        });
        for (const object of objectsToRemove) {
          scene.remove(object);
        }
        board = Array(BOARD_SIZE).fill().map(() => Array(BOARD_SIZE).fill(null));
        gameOver = false;
        if (gameMode === 'multiplayer') {
          if (isHost) {
            gameStarted = true;
            currentPlayer = 'X';
            sendGameMessage({ type: 'reset' });
            updateGameStatus();
            
            // Add chat message
            displayChatMessage("System", "Host reset the game.", "system");
          } else {
            document.getElementById('gameStatus').textContent = "Waiting for host to reset...";
          }
        } else {
          gameStarted = false;
          document.getElementById('playerSelector').style.display = 'block';
          document.getElementById('gameStatus').textContent = "Select who starts";
          
          // Add chat message
          displayChatMessage("System", "Game reset. Select who starts.", "system");
        }
        renderer.render(scene, camera);
      } catch (error) {
        console.error("Error resetting game:", error);
      }
    }
    
    // Reset game from message (for non-host player)
    function resetGameFromMessage() {
      const objectsToRemove = [];
      scene.traverse((object) => {
        if (object.userData && object.userData.type === 'mark') {
          objectsToRemove.push(object);
        }
      });
      for (const object of objectsToRemove) {
        scene.remove(object);
      }
      board = Array(BOARD_SIZE).fill().map(() => Array(BOARD_SIZE).fill(null));
      gameStarted = true;
      currentPlayer = 'X';
      gameOver = false;
      updateGameStatus();
      
      // Add chat message
      displayChatMessage("System", "Host reset the game.", "system");
    }
    
    // Handle keyboard controls
    function onKeyDown(event) {
      // Space bar toggles camera rotation
      if (event.code === 'Space') {
        isCameraAutoRotating = !isCameraAutoRotating;
        
        if (gameMode === 'multiplayer' && connection && connection.open) {
          sendGameMessage({
            type: isCameraAutoRotating ? 'start_camera' : 'stop_camera'
          });
        }
      }
    }
    
    // Handle mouse click with improved hover effects
    function onMouseDown(event) {
      if (!gameStarted || gameOver) return;
      if (gameMode === 'multiplayer' && currentPlayer !== myPlayerSymbol) {
        return;
      }
      
      const mouse = new THREE.Vector2();
      mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
      mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
      
      const raycaster = new THREE.Raycaster();
      raycaster.setFromCamera(mouse, camera);
      
      const intersects = raycaster.intersectObjects(scene.children, true);
      
      for (let i = 0; i < intersects.length; i++) {
        const intersect = intersects[i];
        const object = intersect.object;
        
        if (object.userData && object.userData.type === 'cell') {
          const { row, col } = object.userData;
          placeMark(row, col);
          break;
        }
      }
    }
    
    // Improved mouse hover effect
    function onMouseMove(event) {
      if (!gameStarted || gameOver) return;
      if (gameMode === 'multiplayer' && currentPlayer !== myPlayerSymbol) {
        return;
      }
      
      const mouse = new THREE.Vector2();
      mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
      mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
      
      const raycaster = new THREE.Raycaster();
      raycaster.setFromCamera(mouse, camera);
      
      const intersects = raycaster.intersectObjects(scene.children, true);
      let hoveredCell = null;
      
      for (let i = 0; i < intersects.length; i++) {
        const object = intersects[i].object;
        if (object.userData && object.userData.type === 'cell') {
          hoveredCell = object.userData;
          break;
        }
      }
      
      // Update all cell highlights
      scene.traverse((object) => {
        if (object.userData && object.userData.type === 'highlight') {
          if (hoveredCell && object.userData.row === hoveredCell.row && object.userData.col === hoveredCell.col) {
            if (board[hoveredCell.row][hoveredCell.col] === null) {
              object.material.opacity = 0.3;
            }
          } else {
            object.material.opacity = 0;
          }
        }
      });
    }
    
    // Add mouse move event listener for hover effects
    document.addEventListener('mousemove', onMouseMove, false);
    
    // Handle window resize with improved responsive handling
    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
      
      // Adjust camera for different screen sizes
      if (window.innerWidth < 768) {
        // For mobile devices, increase camera distance to see the whole board
        cameraDistance = 14;
        cameraHeight = 12;
      } else {
        // For larger screens
        cameraDistance = 12;
        cameraHeight = 10;
      }
    }
    
    // Animation loop with smooth camera movement and delta time
    function animate() {
      requestAnimationFrame(animate);
      
      const currentTime = Date.now();
      const deltaTime = (currentTime - lastFrameTime) / 1000; // time in seconds
      lastFrameTime = currentTime;
      
      // Limit delta time to avoid big jumps after tab switching
      const limitedDelta = Math.min(deltaTime, 0.1);
      
      // Smoother camera movement
      if (isCameraAutoRotating) {
        // Use time-based rotation for consistent speed
        cameraAngle += cameraRotationSpeed * limitedDelta * 30;
      }
      
      // Smoothly interpolate camera position for stable rotation
      const targetX = cameraDistance * Math.sin(cameraAngle);
      const targetZ = cameraDistance * Math.cos(cameraAngle);
      
      // Smoother interpolation with weighted blending
      camera.position.x += (targetX - camera.position.x) * 0.03;
      camera.position.z += (targetZ - camera.position.z) * 0.03;
      
      // Always look at the center
      camera.lookAt(0, 0, 0);
      
      // Animate piece placement
      scene.traverse((object) => {
        if (object.userData && object.userData.animating) {
          object.userData.animationProgress += 0.1;
          const progress = Math.min(object.userData.animationProgress, 1);
          
          // Ease-out function for smoother animation
          const scale = 1 - Math.pow(1 - progress, 3);
          object.scale.set(scale, scale, scale);
          
          if (progress >= 1) {
            object.userData.animating = false;
          }
        }
      });
      
      // Animate falling marks (loser's pieces)
      scene.traverse((object) => {
        if (object.userData && object.userData.falling) {
          // Use the individual fall speed and rotation speed
          object.position.y -= object.userData.fallSpeed || 0.05;
          
          if (object.userData.rotationSpeed) {
            object.rotation.x += object.userData.rotationSpeed.x;
            object.rotation.y += object.userData.rotationSpeed.y;
            object.rotation.z += object.userData.rotationSpeed.z;
          } else {
            object.rotation.x += 0.05;
            object.rotation.y += 0.05;
          }
          
          // Remove from scene if below the floor
          if (object.position.y < -5) {
            scene.remove(object);
          }
        }
      });
      
      renderer.render(scene, camera);
    }
    
    // Initialize when window loads
    window.addEventListener('load', () => {
      console.log("Window loaded - game initialization complete");
      lastFrameTime = Date.now();
    });
  </script>
</body>
</html>
